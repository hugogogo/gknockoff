var_plus_ko[[i]]
stat_ko
length(stat_ko)
gr_ind
load("GD_20.RData")
i <- 1
name_var <- colnames(xx[[i]])
name_var
name_gr <- names(group)
name_gr
group
group_name
var_name <- colnames(xx[[i]])[group != 0]
var_name
group
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
browser()
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]]])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]]])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = method, sigma = sigma, randomize = randomize)
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group, loss = loss)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus]
gr_zero[[i]] <- group_name[selected_zero]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
ty <- do_analysis(qq = 0.2, year = 20)
var_plus_ko[[i]]
gr_plus_ko
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
browser()
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]]])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]]])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = "equi", sigma = sigma, randomize = randomize)
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group, loss = loss)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus]
gr_zero[[i]] <- group_name[selected_zero]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
ty <- do_analysis(qq = 0.2, year = 20)
n
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
browser()
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]]])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]]])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = "equi")
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group, loss = loss)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus]
gr_zero[[i]] <- group_name[selected_zero]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
set.seed(123)
ty <- do_analysis(qq = 0.2, year = 20)
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
browser()
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]]])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]]])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = "equi")
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus]
gr_zero[[i]] <- group_name[selected_zero]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
set.seed(123)
ty <- do_analysis(qq = 0.2, year = 20)
stat
selected_zero
group_name
length(stat)
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
browser()
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]]])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]]])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = "equi")
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus + 1]
gr_zero[[i]] <- group_name[selected_zero + 1]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
set.seed(123)
ty <- do_analysis(qq = 0.2, year = 20)
selected_ko_plus
selected_ko_plus <- c(1, 2, 3)
var_plus_ko[[i]]
var_name
gr_plus_ko[[i]]
length(selected_ko_plus)
length9stat_ko
length(stat_ko)
var_plus_ko[[i]]
group[var_plus_ko[[i]]]
group
group_name[group[var_plus_ko[[i]]]]
group_name[group[var_plus_ko[[i]]] + 1]
var_plus_ko[[i]]
library(gknockoff)
do_analysis <- function(qq = 0.2, year = 20){
if(year == 20){
load("GD_20.RData")
m <- 7
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr", "80 yr", "85 yr", "90 yr")
}
else if(year == 35){
load("GD_35.RData")
m <- 4
list_name <- c("60 yr", "65 yr", "70 yr", "75 yr")
}
else{
error("year has to be either 20 or 35!")
}
# non-fixed groups
gm <- group[group != 0]
# for different years
gr_plus <- list()
gr_zero <- list()
gr_plus_ko <- list()
gr_zero_ko <- list()
var_plus_ko <- list()
var_zero_ko <- list()
for(i in seq(m)){
x <- as.matrix(xx[[i]])
y <- as.numeric(yy[[i]])
var_name <- colnames(xx[[i]])[group != 0]
# we first grab the variables that need to be selected
xm <- x[, which(group != 0)]
d <- ncol(xm)
# individual groups used for regular knockoff (with conditioning set)
gr_ind <- c(rep(0, sum(group == 0)), seq(d))
# conditioning set: variables that are known to be in the model, and thus will not be selected
xo <- x[, which(group == 0)]
## regular knockoff (with conditioning set)
ko <- gknockoff::create_fix_gko(x = xm, y = y, group = seq(d), method = "equi")
# compute individual knockoff statistics
stat_ko <- gknockoff::stat_gglasso_lambda(xo = xo, gko = ko, group = gr_ind)
# knockoff
t_ko_zero <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = FALSE)
# return the selected variables
selected_ko_zero <- which(stat_ko >= t_ko_zero)
# knockoff+
t_ko_plus <- gknockoff::thresh_gko(stat = stat_ko, q = qq, plus = TRUE)
# return the selected variables
selected_ko_plus <- which(stat_ko >= t_ko_plus)
var_plus_ko[[i]] <- var_name[selected_ko_plus]
var_zero_ko[[i]] <- var_name[selected_ko_zero]
gr_plus_ko[[i]] <- unique(group_name[group[var_plus_ko[[i]]] + 1])
gr_zero_ko[[i]] <- unique(group_name[group[var_zero_ko[[i]]] + 1])
### group knockoffs
gko <- gknockoff::create_fix_gko(x = xm, y = y, group = gm, method = "equi")
# compute group knockoff statistics
stat <- gknockoff::stat_gglasso_lambda(xo = xo, gko = gko, group = group)
# compute the filtering threshold
t_zero <- gknockoff::thresh_gko(stat = stat, q = qq, plus = FALSE)
# return the selected groups
selected_zero <- which(stat >= t_zero)
# gknockoff+
# compute statistics threshold
t_plus <- gknockoff::thresh_gko(stat = stat, q = qq, plus = TRUE)
# return the selected groups
selected_plus <- which(stat >= t_plus)
gr_plus[[i]] <- group_name[selected_plus + 1]
gr_zero[[i]] <- group_name[selected_zero + 1]
}
names(gr_plus) <- list_name
names(gr_zero) <- list_name
names(gr_plus_ko) <- list_name
names(gr_zero_ko) <- list_name
names(var_plus_ko) <- list_name
names(var_zero_ko) <- list_name
return(list(gr_plus = gr_plus, gr_zero = gr_zero,
gr_plus_ko = gr_plus_ko, gr_zero_ko = gr_zero_ko,
var_plus_ko = var_plus_ko, var_zero_ko = var_zero_ko))
}
?svd
